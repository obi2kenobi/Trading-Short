//@version=6
// ──────────────────────────────────────────────────────────────────────────────
// @title        TEMA-ST-WT PANIC HUNTER v3.1
// @description  Short aggressivo ottimizzato per catturare il panico di mercato
//               Trailing stop dinamico, partial exits, panic detection avanzato
//               v3.1: parametri adattivi TF, drawdown protection, exit ponderati, TP dinamici
// @version      3.1
// @author       Ottimizzato per velocità e profitto
// ──────────────────────────────────────────────────────────────────────────────

// — INPUT TIMEFRAME —
tf = input.string("120", "Timeframe operativo", options = ["60","120","240","D"])
tf_filter = input.string("D", "Timeframe filtro bear market", options = ["D","W"])

// — DATI MULTITF —
[close_tf, high_tf, low_tf, hl2_tf, hlc3_tf, vol_tf, open_tf] = request.security(syminfo.tickerid, tf, [close, high, low, hl2, hlc3, volume, open])
close_htf = request.security(syminfo.tickerid, tf_filter, close)

// — STRATEGY SETTINGS —
strategy("TEMA-ST-WT PANIC HUNTER v3.1", overlay=true,
     initial_capital    = 100000,
     default_qty_type   = strategy.percent_of_equity,
     default_qty_value  = 100,
     pyramiding         = 0,
     commission_type    = strategy.commission.percent,
     commission_value   = 0.01,
     calc_on_every_tick = true)

// ═══════════════════════════════════════════════════════════════════════════════
// INPUT PARAMETERS - RISK MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════

grpRisk = "═══ RISK MANAGEMENT ═══"
stopPerc_normal = input.float(2.0, "Stop Loss Normale %", minval=0.5, maxval=5.0, step=0.1, group=grpRisk) / 100
stopPerc_panic = input.float(1.2, "Stop Loss Panic Mode %", minval=0.3, maxval=3.0, step=0.1, group=grpRisk) / 100
useTrailingStop = input.bool(true, "Usa Trailing Stop", group=grpRisk)
trailATRmult = input.float(1.5, "Trailing Stop ATR Multiplier", minval=0.5, maxval=4.0, step=0.1, group=grpRisk)

grpTP = "═══ TAKE PROFIT SCALATO ═══"
usePartialTP = input.bool(true, "Usa Take Profit Parziali", group=grpTP)
useDynamicTP = input.bool(true, "TP Dinamici (basati su ATR)", group=grpTP, tooltip="I TP si adattano alla volatilità corrente. I valori % diventano fallback")
tp1_perc_input = input.float(2.5, "TP1 % (fallback se TP dinamici off)", minval=1.0, maxval=5.0, step=0.5, group=grpTP) / 100
tp1_size = input.float(40, "TP1 Size %", minval=10, maxval=60, step=5, group=grpTP) / 100
tp2_perc_input = input.float(5.0, "TP2 % (fallback)", minval=2.0, maxval=10.0, step=0.5, group=grpTP) / 100
tp2_size = input.float(35, "TP2 Size %", minval=10, maxval=50, step=5, group=grpTP) / 100
tp3_perc_input = input.float(8.0, "TP3 % finale (fallback)", minval=3.0, maxval=15.0, step=0.5, group=grpTP) / 100
tpATRmult1 = input.float(1.5, "TP1 ATR Multiplier", minval=0.5, maxval=4.0, step=0.1, group=grpTP, tooltip="TP1 = entry - ATR * questo valore")
tpATRmult2 = input.float(3.0, "TP2 ATR Multiplier", minval=1.0, maxval=6.0, step=0.1, group=grpTP)
tpATRmult3 = input.float(5.0, "TP3 ATR Multiplier", minval=2.0, maxval=10.0, step=0.1, group=grpTP)

grpPanic = "═══ PANIC DETECTION ═══"
volSpikeMultiplier = input.float(2.0, "Volume Spike Multiplier", minval=1.5, maxval=4.0, step=0.1, group=grpPanic)
panicBarATRmult = input.float(1.5, "Panic Bar Size (ATR mult)", minval=1.0, maxval=3.0, step=0.1, group=grpPanic)
rsiPanicLevel = input.int(35, "RSI Panic Threshold", minval=20, maxval=45, group=grpPanic)
usePanicMode = input.bool(true, "Abilita Panic Mode Aggressivo", group=grpPanic)

grpDrawdown = "═══ DRAWDOWN PROTECTION ═══"
useDrawdownProtection = input.bool(true, "Abilita Protezione Drawdown", group=grpDrawdown)
maxDailyDrawdown = input.float(5.0, "Max Drawdown Giornaliero %", minval=1.0, maxval=15.0, step=0.5, group=grpDrawdown, tooltip="Blocca nuovi trade se il drawdown giornaliero supera questa soglia") / 100
maxTotalDrawdown = input.float(12.0, "Max Drawdown Totale %", minval=3.0, maxval=30.0, step=1.0, group=grpDrawdown, tooltip="Blocca nuovi trade se il drawdown totale supera questa soglia") / 100
maxConsecutiveLosses = input.int(3, "Max Perdite Consecutive", minval=1, maxval=6, group=grpDrawdown, tooltip="Dopo N perdite consecutive, pausa forzata")

grpFilter = "═══ FILTRI MERCATO ═══"
useBearFilter = input.bool(false, "Richiedi Bear Market (sotto TEMA200)", group=grpFilter, tooltip="Se disattivato, opera anche in bull market")
useVolumeFilter = input.bool(true, "Richiedi Volume Alto", group=grpFilter)
useLateralFilter = input.bool(true, "Evita Mercati Laterali", group=grpFilter)
useSessionFilter = input.bool(true, "Filtro Sessione (solo 4H)", group=grpFilter, tooltip="Su 4H, evita entry in orari a bassa liquidità. Ignorato su Daily")
sessionStart = input.int(8, "Sessione Inizio (UTC)", minval=0, maxval=23, group=grpFilter, tooltip="Ora UTC di inizio sessione attiva")
sessionEnd = input.int(21, "Sessione Fine (UTC)", minval=0, maxval=23, group=grpFilter, tooltip="Ora UTC di fine sessione attiva")

grpBearMode = "═══ SHORT BEAR (più selettivo) ═══"
useBearMode = input.bool(true, "Abilita SHORT BEAR mode", group=grpBearMode)
bearMinFear = input.float(12.0, "Fear Index minimo per BEAR %", minval=0, maxval=30, step=1, group=grpBearMode, tooltip="BEAR richiede almeno questo livello di paura")
bearMinRedBars = input.int(2, "Candele rosse consecutive minime", minval=1, maxval=5, group=grpBearMode)
cooldownBars = input.int(8, "Cooldown tra trade (barre)", minval=0, maxval=20, group=grpBearMode, tooltip="Barre minime tra un'uscita e una nuova entry")

grpIndicators = "═══ INDICATORI ═══"
temaLen_in = input.int(28, "TEMA IN Period", minval=10, maxval=50, group=grpIndicators)
temaLen_out = input.int(24, "TEMA OUT Period", minval=10, maxval=50, group=grpIndicators)
stFactor_in = input.float(2.4, "Supertrend IN Factor", minval=1.5, maxval=4.0, step=0.1, group=grpIndicators)
stFactor_out = input.float(2.2, "Supertrend OUT Factor", minval=1.5, maxval=4.0, step=0.1, group=grpIndicators)
maxDistATR = input.float(1.8, "Max Distance ATR", minval=0.5, maxval=3.0, step=0.1, group=grpIndicators)

grpVisual = "═══ VISUALIZZAZIONE ═══"
showLabels = input.bool(true, "Mostra labels trade", group=grpVisual)
compactLabels = input.bool(true, "Labels compatte", group=grpVisual, tooltip="Mostra solo info essenziali nelle label")
labelSize = input.string("small", "Dimensione labels", options=["tiny", "small", "normal"], group=grpVisual)
showDashboard = input.bool(true, "Mostra dashboard", group=grpVisual)
showLevels = input.bool(true, "Mostra livelli SL/TP", group=grpVisual)
showBearFilter = input.bool(true, "Mostra TEMA 200 HTF", group=grpVisual)
showPanicZones = input.bool(false, "Evidenzia zone panic", group=grpVisual)
labelOffsetATR = input.float(3.0, "Distanza Labels (ATR multiplier)", minval=1.0, maxval=8.0, step=0.5, group=grpVisual, tooltip="Distanza delle label dalle candele in multipli di ATR")

// ═══════════════════════════════════════════════════════════════════════════════
// FILTRO BEAR MARKET
// ═══════════════════════════════════════════════════════════════════════════════

tema200_htf = request.security(syminfo.tickerid, tf_filter, 3*ta.ema(close, 200) - 3*ta.ema(ta.ema(close, 200), 200) + ta.ema(ta.ema(ta.ema(close, 200), 200), 200))
ema50_htf = request.security(syminfo.tickerid, tf_filter, ta.ema(close, 50))

// Bear market confermato: prezzo sotto TEMA200 E EMA50 sotto TEMA200
isBearMarket = close_htf < tema200_htf
isStrongBear = isBearMarket and ema50_htf < tema200_htf

// ═══════════════════════════════════════════════════════════════════════════════
// PARAMETRI ADATTIVI PER TIMEFRAME
// ═══════════════════════════════════════════════════════════════════════════════

// Timeframe detection: 4h ha movimenti più veloci, 1D più lenti e significativi
is4H = tf == "240"
isDaily = tf == "D"
isHighTF = isDaily

// Moltiplicatore adattivo: 1D richiede soglie più larghe, 4H più strette
tfStopMult   = isDaily ? 1.4 : (is4H ? 1.0 : 1.2)  // SL più largo su 1D
tfTrailMult  = isDaily ? 1.3 : (is4H ? 1.0 : 1.1)  // Trailing più largo su 1D
tfPanicMult  = isDaily ? 1.5 : (is4H ? 1.0 : 1.2)  // Panic bar più significativa su 1D
tfCooldownMult = isDaily ? 0.5 : (is4H ? 1.0 : 0.75)  // Meno cooldown su 1D (meno barre)

// Parametri adattati
adaptedStopNormal = stopPerc_normal * tfStopMult
adaptedStopPanic  = stopPerc_panic * tfStopMult
adaptedTrailATR   = trailATRmult * tfTrailMult
adaptedCooldown   = math.round(cooldownBars * tfCooldownMult)
adaptedPanicBarATR = panicBarATRmult * tfPanicMult

// ═══════════════════════════════════════════════════════════════════════════════
// PARAMETRI INTERNI
// ═══════════════════════════════════════════════════════════════════════════════

stPeriod = 10
wtN1 = 10
wtN2 = 21
rsiLen = 14

// ═══════════════════════════════════════════════════════════════════════════════
// PANIC DETECTION MODULE
// ═══════════════════════════════════════════════════════════════════════════════

// ATR per misurazioni
atr14 = ta.atr(14)
atr10 = ta.atr(10)

// 1. VOLUME SPIKE DETECTION
volMA20 = ta.sma(vol_tf, 20)
volMA5 = ta.sma(vol_tf, 5)
isVolSpike = vol_tf > volMA20 * volSpikeMultiplier
isVolAccelerating = volMA5 > volMA20 * 1.3

// 2. PANIC BAR DETECTION (candele di panico)
candleBody = math.abs(close_tf - open_tf)
candleRange = high_tf - low_tf
isBearishCandle = close_tf < open_tf
isPanicBar = isBearishCandle and candleBody > atr14 * adaptedPanicBarATR and candleBody > candleRange * 0.7

// 3. RSI CRASH DETECTION
rsi = ta.rsi(close_tf, rsiLen)
rsi_prev = rsi[1]  // usa il valore RSI della barra precedente, non ricalcolare
isRsiPanic = rsi < rsiPanicLevel
isRsiCrashing = rsi < rsi_prev - 5 and rsi < 50  // RSI in caduta rapida

// 4. PRICE VELOCITY (accelerazione discesa)
priceChange1 = (close_tf - close_tf[1]) / close_tf[1] * 100
priceChange3 = (close_tf - close_tf[3]) / close_tf[3] * 100
isPriceAccelerating = priceChange1 < -0.5 and priceChange3 < -1.5

// 5. GAP DOWN DETECTION
gapDown = open_tf < low_tf[1]
significantGap = gapDown and (low_tf[1] - open_tf) > atr14 * 0.5

// 6. CONSECUTIVE RED BARS
redBar = close_tf < open_tf
consecutiveRed = redBar and redBar[1] and redBar[2]

// PANIC SCORE (0-100)
panicScore = 0
panicScore := panicScore + (isVolSpike ? 20 : 0)
panicScore := panicScore + (isPanicBar ? 25 : 0)
panicScore := panicScore + (isRsiPanic ? 15 : 0)
panicScore := panicScore + (isRsiCrashing ? 10 : 0)
panicScore := panicScore + (isPriceAccelerating ? 15 : 0)
panicScore := panicScore + (significantGap ? 10 : 0)
panicScore := panicScore + (consecutiveRed ? 5 : 0)

// PANIC MODE ATTIVO se score >= 40
isPanicMode = panicScore >= 40 and usePanicMode

// ═══════════════════════════════════════════════════════════════════════════════
// FEAR INDEX (indicatore interno di paura)
// ═══════════════════════════════════════════════════════════════════════════════

// Volatility component
atrNorm = atr14 / ta.sma(atr14, 50) * 100 - 100  // deviazione dalla media
volComponent = math.min(50, math.max(0, atrNorm))

// RSI component (inverted: lower RSI = more fear)
rsiComponent = math.min(50, math.max(0, (50 - rsi)))

// Volume component
volRatio = vol_tf / volMA20
volFearComponent = math.min(30, math.max(0, (volRatio - 1) * 30))

// FEAR INDEX (0-100)
fearIndex = (volComponent * 0.3 + rsiComponent * 0.4 + volFearComponent * 0.3)
isHighFear = fearIndex > 35

// ═══════════════════════════════════════════════════════════════════════════════
// CORE INDICATORS
// ═══════════════════════════════════════════════════════════════════════════════

// TEMA IN / OUT (più veloci)
tema_in  = 3*ta.ema(close_tf, temaLen_in) - 3*ta.ema(ta.ema(close_tf, temaLen_in), temaLen_in) + ta.ema(ta.ema(ta.ema(close_tf, temaLen_in), temaLen_in), temaLen_in)
tema_out = 3*ta.ema(close_tf, temaLen_out) - 3*ta.ema(ta.ema(close_tf, temaLen_out), temaLen_out) + ta.ema(ta.ema(ta.ema(close_tf, temaLen_out), temaLen_out), temaLen_out)

// TEMA Slope
tema_slope = tema_in - tema_in[1]
tema_slope_ma = ta.sma(tema_slope, 3)
isTemaFalling = tema_slope < 0 and tema_slope_ma < 0
isTemaAccelerating = tema_slope < tema_slope[1] and tema_slope < 0

// Supertrend IN
upC_in = hl2_tf - stFactor_in * atr10
dnC_in = hl2_tf + stFactor_in * atr10
var float _up_in = na
var float _dn_in = na
var int trend_in = 0
_up_in := close_tf[1] > nz(_up_in[1], upC_in) ? math.max(upC_in, nz(_up_in[1], upC_in)) : upC_in
_dn_in := close_tf[1] < nz(_dn_in[1], dnC_in) ? math.min(dnC_in, nz(_dn_in[1], dnC_in)) : dnC_in
trend_in := close_tf > _dn_in[1] ? 1 : close_tf < _up_in[1] ? -1 : nz(trend_in[1])

// Supertrend OUT (più sensibile per exit veloci)
upC_out = hl2_tf - stFactor_out * atr10
dnC_out = hl2_tf + stFactor_out * atr10
var float _up_out = na
var float _dn_out = na
var int trend_out = 0
_up_out := close_tf[1] > nz(_up_out[1], upC_out) ? math.max(upC_out, nz(_up_out[1], upC_out)) : upC_out
_dn_out := close_tf[1] < nz(_dn_out[1], dnC_out) ? math.min(dnC_out, nz(_dn_out[1], dnC_out)) : dnC_out
trend_out := close_tf > _dn_out[1] ? 1 : close_tf < _up_out[1] ? -1 : nz(trend_out[1])

// WT IN (Wave Trend)
ap_in  = hlc3_tf
esa_in = ta.ema(ap_in, wtN1)
d_in   = ta.ema(math.abs(ap_in - esa_in), wtN1)
ci_in  = (ap_in - esa_in) / (0.015 * d_in)
wt1_in = ta.ema(ci_in, wtN2)
wt2_in = ta.sma(wt1_in, 4)
wtDown = wt1_in < wt2_in
wtCrossDown = ta.crossunder(wt1_in, wt2_in)

// WT OUT
ap_out  = hlc3_tf
esa_out = ta.ema(ap_out, wtN1)
d_out   = ta.ema(math.abs(ap_out - esa_out), wtN1)
ci_out  = (ap_out - esa_out) / (0.015 * d_out)
wt1_out = ta.ema(ci_out, wtN2)
wt2_out = ta.sma(wt1_out, 4)
wtUp = ta.crossover(wt1_out, wt2_out)
wtBullish = wt1_out > wt2_out

// Distance from TEMA
distATR = (tema_in - close_tf) / atr10

// ═══════════════════════════════════════════════════════════════════════════════
// ENTRY CONDITIONS
// ═══════════════════════════════════════════════════════════════════════════════

// Filtro lateralità (più permissivo in panic)
tema_slope_ratio = math.abs(tema_slope) / atr10
activeSlopeThreshold = isPanicMode ? 0.005 : (isBearMarket ? 0.012 : 0.015)
isFlatSlope = tema_slope_ratio < activeSlopeThreshold

rangeHigh5 = ta.highest(high_tf, 5)
rangeLow5  = ta.lowest(low_tf, 5)
rangeCond  = (rangeHigh5 - rangeLow5) / close_tf < 0.008
isLateral  = isFlatSlope and rangeCond and not isPanicMode

// Filtro volume (più permissivo in panic)
activeVolMult = isPanicMode ? 0.8 : (isBearMarket ? 1.0 : 1.2)
highVolume = vol_tf > volMA20 * activeVolMult

// Filtro sessione: su 4H evita orari morti, su Daily sempre attivo
currentHour = hour(time, "UTC")
inActiveSession = sessionStart < sessionEnd ? (currentHour >= sessionStart and currentHour < sessionEnd) : (currentHour >= sessionStart or currentHour < sessionEnd)
sessionOK = (not useSessionFilter) or isDaily or inActiveSession

// Filtri condizionali
bearOK = useBearFilter ? isBearMarket : true
volOK = useVolumeFilter ? highVolume : true
latOK = useLateralFilter ? not isLateral : true

// ═══════════════════════════════════════════════════════════════════════════════
// COOLDOWN & BEAR MODE FILTERS
// ═══════════════════════════════════════════════════════════════════════════════

// Track ultima uscita per cooldown e re-entry intelligente
var int lastExitBar = 0
var bool lastTradeWasProfit = false
var float lastExitProfit = 0.0
inShort = strategy.position_size < 0

// Aggiorna lastExitBar quando usciamo da posizione
if inShort[1] and not inShort
    lastExitBar := bar_index
    lastExitProfit := (entryPrice - close_tf) / entryPrice
    lastTradeWasProfit := lastExitProfit > 0

// Cooldown intelligente: ridotto dopo trade profittevole se il trend continua
barsSinceExit = bar_index - lastExitBar
// Se l'ultimo trade era in profitto E il trend continua a scendere, cooldown dimezzato
smartCooldown = lastTradeWasProfit and isTemaFalling and (trend_in == -1) ? math.round(adaptedCooldown * 0.5) : adaptedCooldown
cooldownOK = barsSinceExit >= smartCooldown

// Conta candele rosse consecutive (per BEAR mode)
redBarsCount = 0
redBarsCount := close_tf < open_tf ? redBarsCount[1] + 1 : 0
hasEnoughRedBars = redBarsCount >= bearMinRedBars

// Fear Index minimo per BEAR
fearOK_bear = fearIndex >= bearMinFear

// ═══════════════════════════════════════════════════════════════════════════════
// DRAWDOWN PROTECTION
// ═══════════════════════════════════════════════════════════════════════════════

// Track equity giornaliero per drawdown
var float dailyStartEquity = strategy.equity
var int lastDay = dayofweek

// Reset equity giornaliero a inizio giornata
if dayofweek != lastDay
    dailyStartEquity := strategy.equity
    lastDay := dayofweek

// Calcolo drawdown giornaliero
dailyDrawdown = dailyStartEquity > 0 ? (dailyStartEquity - strategy.equity) / dailyStartEquity : 0.0

// Calcolo drawdown totale dall'equity massimo
var float peakEquity = strategy.initial_capital
peakEquity := math.max(peakEquity, strategy.equity)
totalDrawdown = peakEquity > 0 ? (peakEquity - strategy.equity) / peakEquity : 0.0

// Track perdite consecutive
var int consecutiveLosses = 0
if inShort[1] and not inShort
    // Posizione appena chiusa - controlla se in profitto o perdita
    if strategy.equity < strategy.equity[1]
        consecutiveLosses += 1
    else
        consecutiveLosses := 0

// Circuit breaker attivo?
dailyDrawdownOK = not useDrawdownProtection or dailyDrawdown < maxDailyDrawdown
totalDrawdownOK = not useDrawdownProtection or totalDrawdown < maxTotalDrawdown
consecutiveLossOK = not useDrawdownProtection or consecutiveLosses < maxConsecutiveLosses
drawdownOK = dailyDrawdownOK and totalDrawdownOK and consecutiveLossOK

// ═══════════════════════════════════════════════════════════════════════════════
// ENTRY SIGNALS
// ═══════════════════════════════════════════════════════════════════════════════

// CONDIZIONE SHORT STANDARD (BEAR) - ora molto più restrittiva
shortBearConditions = (trend_in == -1) and wtDown and isTemaFalling and (distATR <= maxDistATR) and latOK and volOK and bearOK and sessionOK
shortBearFilters = hasEnoughRedBars and fearOK_bear and cooldownOK and drawdownOK
shortStandard = useBearMode and shortBearConditions and shortBearFilters

// CONDIZIONE SHORT PANIC (più aggressiva - ignora alcuni filtri, ma rispetta cooldown e drawdown)
shortPanic = isPanicMode and (trend_in == -1 or isPanicBar) and (wtDown or isRsiPanic) and isVolSpike and cooldownOK and drawdownOK

// CONDIZIONE SHORT FINALE
shortOK = shortStandard or shortPanic

// Entry
if not inShort and shortOK
    strategy.entry("Short", strategy.short)

// ═══════════════════════════════════════════════════════════════════════════════
// POSITION MANAGEMENT & TRAILING STOP
// ═══════════════════════════════════════════════════════════════════════════════

var float entryPrice = na
var int entryBar = na
var float trailStop = na
var float lowestSinceEntry = na
var bool tp1_hit = false
var bool tp2_hit = false
var string entryMode = ""

// Reset on new position
if inShort and not inShort[1]
    entryPrice := strategy.position_avg_price
    entryBar := bar_index
    trailStop := entryPrice * (1 + (isPanicMode ? adaptedStopPanic : adaptedStopNormal))
    lowestSinceEntry := close_tf
    tp1_hit := false
    tp2_hit := false
    entryMode := isPanicMode ? "PANIC" : "STANDARD"

// Update trailing stop
if inShort
    lowestSinceEntry := math.min(lowestSinceEntry, low_tf)

    if useTrailingStop
        // Trailing stop basato su ATR dal minimo
        newTrailStop = lowestSinceEntry + atr14 * adaptedTrailATR

        // Il trailing stop può solo scendere (per short), con guard per na
        if na(trailStop) or newTrailStop < trailStop
            trailStop := newTrailStop

// Calcolo livelli
activeStopPerc = isPanicMode ? adaptedStopPanic : adaptedStopNormal
stopPrice = useTrailingStop ? trailStop : entryPrice * (1 + activeStopPerc)

// TP dinamici: basati su ATR al momento dell'entry, o % fisse come fallback
var float entryATR = na
if inShort and not inShort[1]
    entryATR := atr14

// Calcola TP percentuali: usa ATR se abilitato, altrimenti % fissa
tp1_perc = useDynamicTP and not na(entryATR) and entryATR > 0 ? (entryATR * tpATRmult1) / entryPrice : tp1_perc_input
tp2_perc = useDynamicTP and not na(entryATR) and entryATR > 0 ? (entryATR * tpATRmult2) / entryPrice : tp2_perc_input
tp3_perc = useDynamicTP and not na(entryATR) and entryATR > 0 ? (entryATR * tpATRmult3) / entryPrice : tp3_perc_input

tp1Price = entryPrice * (1 - tp1_perc)
tp2Price = entryPrice * (1 - tp2_perc)
tp3Price = entryPrice * (1 - tp3_perc)

// ═══════════════════════════════════════════════════════════════════════════════
// EXIT CONDITIONS (VELOCIZZATE)
// ═══════════════════════════════════════════════════════════════════════════════

// Exit signals con pesi (segnali più forti valgono di più)
exit_wt = wtUp or wtBullish
exit_st = trend_out == 1
exit_tema = close_tf > tema_out
exit_rsi = rsi > 55 and rsi > rsi_prev  // RSI in risalita sopra 55

// Pesi exit: Supertrend flip è il segnale più forte, WT il più debole
wt_exit_st   = 3.0   // Supertrend flip = segnale strutturale forte
wt_exit_tema = 2.5   // Prezzo sopra TEMA = inversione trend
wt_exit_rsi  = 2.0   // RSI in risalita = momentum cambia
wt_exit_wt   = 1.5   // WT bullish = più rumoroso, peso minore

// Profit già realizzato
currentProfit = inShort ? (entryPrice - close_tf) / entryPrice : 0
hasProfit = currentProfit > tp1_perc

// EXIT PONDERATO: soglia 4.0 in profitto, 6.0 in perdita
exitScore = (exit_wt ? wt_exit_wt : 0) + (exit_st ? wt_exit_st : 0) + (exit_tema ? wt_exit_tema : 0) + (exit_rsi ? wt_exit_rsi : 0)
exitThreshold = hasProfit ? 4.0 : 6.0
shouldExit = exitScore >= exitThreshold

// Emergency exit: RSI > 65 (forte rimbalzo)
emergencyExit = rsi > 65 and inShort

exit_bar = inShort and (shouldExit or emergencyExit)

// ═══════════════════════════════════════════════════════════════════════════════
// EXECUTE EXITS
// ═══════════════════════════════════════════════════════════════════════════════

if inShort
    // Take Profit Parziali
    if usePartialTP
        // TP1
        if not tp1_hit and close_tf <= tp1Price
            strategy.close("Short", comment="TP1", qty_percent=tp1_size * 100)
            tp1_hit := true

        // TP2 - qty_percent è relativo alla posizione rimanente (dopo TP1)
        if not tp2_hit and tp1_hit and close_tf <= tp2Price
            remainingAfterTP1 = 1.0 - tp1_size
            tp2_qty = math.min(tp2_size / remainingAfterTP1 * 100, 100)
            strategy.close("Short", comment="TP2", qty_percent=tp2_qty)
            tp2_hit := true

        // TP3 finale
        strategy.exit("TP3/SL", from_entry="Short", stop=stopPrice, limit=tp3Price)
    else
        // Single TP/SL
        strategy.exit("SL/TP", from_entry="Short", stop=stopPrice, limit=tp3Price)

    // Signal-based exit - emergency esce sempre, cover solo se TP1 già colpito o TP disabilitati
    if exit_bar
        if emergencyExit
            strategy.close("Short", comment="EMERGENCY")
        else if not usePartialTP or tp1_hit
            strategy.close("Short", comment="Cover")

// ═══════════════════════════════════════════════════════════════════════════════
// PLOTS
// ═══════════════════════════════════════════════════════════════════════════════

// TEMA 200 HTF
plot(showBearFilter ? tema200_htf : na, "TEMA 200 HTF", color=isBearMarket ? color.new(color.red, 40) : color.new(color.green, 40), linewidth=3)

// TEMA lines
plot(tema_in, "TEMA IN", color=color.new(color.purple, 0), linewidth=2)
plot(tema_out, "TEMA OUT", color=color.new(color.blue, 50), linewidth=1, style=plot.style_circles)

// Supertrend
plot(trend_in==-1 ? _dn_in : na, "ST Dn", color=color.new(color.red, 0), linewidth=2, style=plot.style_linebr)
plot(trend_in==1 ? _up_in : na, "ST Up", color=color.new(color.green, 0), linewidth=2, style=plot.style_linebr)

// Background
bgcolor(showPanicZones and isPanicMode ? color.new(color.orange, 85) : na, title="Panic Zone")
bgcolor(isBearMarket ? color.new(color.red, 97) : color.new(color.green, 97), title="Bear/Bull")
bgcolor(inShort ? color.new(color.red, 92) : na, title="In Position")

// SL/TP levels
plot(showLevels and inShort ? stopPrice : na, "Stop Loss", color=color.new(color.red, 0), linewidth=2, style=plot.style_cross)
plot(showLevels and inShort ? tp1Price : na, "TP1", color=color.new(color.lime, 60), linewidth=1, style=plot.style_circles)
plot(showLevels and inShort ? tp2Price : na, "TP2", color=color.new(color.lime, 40), linewidth=1, style=plot.style_circles)
plot(showLevels and inShort ? tp3Price : na, "TP3", color=color.new(color.green, 0), linewidth=2, style=plot.style_cross)
plot(showLevels and inShort ? entryPrice : na, "Entry", color=color.new(color.white, 0), linewidth=1, style=plot.style_circles)

// Entry signals
plotshape(shortStandard and not inShort and not shortPanic, "SHORT STD", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.normal)
plotshape(shortPanic and not inShort, "SHORT PANIC", shape.triangledown, location.abovebar, color.new(color.orange, 0), size=size.large)

// Exit signals
plotshape(exit_bar and not emergencyExit, "COVER", shape.triangleup, location.belowbar, color.new(color.lime, 0), size=size.normal)
plotshape(emergencyExit, "EMERGENCY", shape.xcross, location.belowbar, color.new(color.yellow, 0), size=size.large)

// Panic indicators
plotshape(showPanicZones and isPanicBar and not inShort, "Panic Bar", shape.circle, location.belowbar, color.new(color.orange, 0), size=size.tiny)
plotshape(showPanicZones and isVolSpike, "Vol Spike", shape.diamond, location.abovebar, color.new(color.purple, 0), size=size.tiny)

// ═══════════════════════════════════════════════════════════════════════════════
// LABELS
// ═══════════════════════════════════════════════════════════════════════════════

// Calcolo offset per labels
labelOffset = atr14 * labelOffsetATR

// Dimensione label dinamica
lblSize = labelSize == "tiny" ? size.tiny : (labelSize == "small" ? size.small : size.normal)

if showLabels
    // Entry label (sopra le candele con offset)
    if shortOK and not inShort
        modeText = shortPanic ? "PANIC" : (isBearMarket ? "BEAR" : "STD")
        labelColor = shortPanic ? color.orange : color.red

        // Testo compatto o completo
        entryText = compactLabels ?
             "SHORT " + modeText + "\n" + str.tostring(close_tf, "#.##") :
             "SHORT " + modeText + "\nEntry: " + str.tostring(close_tf, "#.##") +
                  "\nSL: " + str.tostring(stopPrice, "#.##") +
                  "\nTP3: " + str.tostring(tp3Price, "#.##")

        label.new(bar_index, high_tf + labelOffset,
             text=entryText,
             style=label.style_label_down,
             color=labelColor,
             textcolor=color.white,
             size=lblSize)

    // Exit label (sotto le candele con offset)
    if exit_bar
        profitPct = ((entryPrice - close_tf) / entryPrice) * 100
        profitColor = profitPct > 0 ? color.green : color.red
        exitType = emergencyExit ? "EXIT!" : "Cover"

        // Testo compatto o completo
        exitText = compactLabels ?
             exitType + " " + str.tostring(profitPct, "#.#") + "%" :
             exitType + "\n" + str.tostring(close_tf, "#.##") +
                  "\nP&L: " + str.tostring(profitPct, "#.##") + "%"

        label.new(bar_index, low_tf - labelOffset,
             text=exitText,
             style=label.style_label_up,
             color=profitColor,
             textcolor=color.white,
             size=lblSize)

// TP hit labels - solo se non compatte
if showLabels and not compactLabels and inShort
    if tp1_hit and not tp1_hit[1]
        label.new(bar_index, low_tf - labelOffset * 0.5,
             text="TP1",
             style=label.style_label_up,
             color=color.new(color.green, 30),
             textcolor=color.white,
             size=size.tiny)
    if tp2_hit and not tp2_hit[1]
        label.new(bar_index, low_tf - labelOffset * 0.5,
             text="TP2",
             style=label.style_label_up,
             color=color.new(color.green, 20),
             textcolor=color.white,
             size=size.tiny)

// ═══════════════════════════════════════════════════════════════════════════════
// DASHBOARD
// ═══════════════════════════════════════════════════════════════════════════════

if showDashboard
    var table dashboard = table.new(position.bottom_right, 2, 18, bgcolor=color.new(color.black, 80), border_width=1)

    // Header
    tfLabel = is4H ? "4H" : (isDaily ? "1D" : tf)
    table.cell(dashboard, 0, 0, "PANIC HUNTER v3.1", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.purple, 60))
    table.cell(dashboard, 1, 0, tfLabel, text_color=color.yellow, text_size=size.normal, bgcolor=color.new(color.purple, 60))

    // Market Status
    marketStatus = isStrongBear ? "STRONG BEAR" : (isBearMarket ? "BEAR" : "BULL")
    marketColor = isStrongBear ? color.red : (isBearMarket ? color.orange : color.green)
    table.cell(dashboard, 0, 1, "Market:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 1, marketStatus, text_color=marketColor, text_size=size.small)

    // Fear Index
    fearColor = fearIndex > 50 ? color.red : (fearIndex > 30 ? color.orange : color.green)
    table.cell(dashboard, 0, 2, "Fear Index:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 2, str.tostring(fearIndex, "#.#") + "%", text_color=fearColor, text_size=size.small)

    // Panic Score
    panicColor = panicScore >= 40 ? color.red : (panicScore >= 25 ? color.orange : color.gray)
    table.cell(dashboard, 0, 3, "Panic Score:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 3, str.tostring(panicScore) + "/100", text_color=panicColor, text_size=size.small)

    // Mode
    modeText = isPanicMode ? "PANIC MODE" : "STANDARD"
    modeColor = isPanicMode ? color.orange : color.white
    table.cell(dashboard, 0, 4, "Mode:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 4, modeText, text_color=modeColor, text_size=size.small)

    // RSI
    rsiColor = rsi < 30 ? color.green : (rsi > 70 ? color.red : color.white)
    table.cell(dashboard, 0, 5, "RSI:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 5, str.tostring(rsi, "#.#"), text_color=rsiColor, text_size=size.small)

    // Volume
    volText = isVolSpike ? "SPIKE!" : (highVolume ? "HIGH" : "NORMAL")
    volColor = isVolSpike ? color.orange : (highVolume ? color.green : color.gray)
    table.cell(dashboard, 0, 6, "Volume:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 6, volText, text_color=volColor, text_size=size.small)

    // Trend
    trendText = trend_in == -1 ? "DOWN" : "UP"
    trendColor = trend_in == -1 ? color.red : color.green
    table.cell(dashboard, 0, 7, "Trend:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 7, trendText, text_color=trendColor, text_size=size.small)

    // Drawdown Protection
    ddText = not drawdownOK ? "BLOCKED" : (dailyDrawdown > maxDailyDrawdown * 0.7 ? "WARNING" : "OK")
    ddColor = not drawdownOK ? color.red : (dailyDrawdown > maxDailyDrawdown * 0.7 ? color.orange : color.green)
    table.cell(dashboard, 0, 8, "DD Protect:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 8, ddText + " " + str.tostring(dailyDrawdown * 100, "#.#") + "%", text_color=ddColor, text_size=size.small)

    // Session filter
    sessText = not is4H ? "N/A" : (inActiveSession ? "ACTIVE" : "INACTIVE")
    sessColor = not is4H ? color.gray : (inActiveSession ? color.green : color.orange)
    table.cell(dashboard, 0, 9, "Session:", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 9, sessText, text_color=sessColor, text_size=size.small)

    // Separator
    table.cell(dashboard, 0, 10, "────────", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 10, "────────", text_color=color.gray, text_size=size.small)

    // Position Info
    if inShort
        table.cell(dashboard, 0, 11, "Position:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 11, "SHORT", text_color=color.red, text_size=size.small)

        table.cell(dashboard, 0, 12, "Entry:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 12, str.tostring(entryPrice, "#.##"), text_color=color.white, text_size=size.small)

        pnlColor = currentProfit > 0 ? color.green : color.red
        table.cell(dashboard, 0, 13, "P&L:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 13, str.tostring(currentProfit * 100, "#.##") + "%", text_color=pnlColor, text_size=size.small)

        table.cell(dashboard, 0, 14, "Trail Stop:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 14, str.tostring(stopPrice, "#.##"), text_color=color.red, text_size=size.small)

        // Exit score
        table.cell(dashboard, 0, 15, "Exit Score:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 15, str.tostring(exitScore, "#.#") + "/" + str.tostring(exitThreshold, "#.#"), text_color=exitScore >= exitThreshold ? color.orange : color.white, text_size=size.small)

        tpStatus = tp2_hit ? "TP2 HIT" : (tp1_hit ? "TP1 HIT" : "RUNNING")
        tpStatusColor = tp2_hit ? color.green : (tp1_hit ? color.lime : color.white)
        table.cell(dashboard, 0, 16, "TP Status:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 16, tpStatus, text_color=tpStatusColor, text_size=size.small)

        // Losses consecutive
        table.cell(dashboard, 0, 17, "Cons. Loss:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 17, str.tostring(consecutiveLosses) + "/" + str.tostring(maxConsecutiveLosses), text_color=consecutiveLosses >= maxConsecutiveLosses - 1 ? color.orange : color.white, text_size=size.small)
    else
        signalText = shortOK ? "READY!" : (not drawdownOK ? "DD BLOCK" : "WAITING")
        signalColor = shortOK ? color.green : (not drawdownOK ? color.red : color.gray)
        table.cell(dashboard, 0, 11, "Signal:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 11, signalText, text_color=signalColor, text_size=size.small)

        table.cell(dashboard, 0, 12, "WT:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 12, wtDown ? "BEARISH" : "BULLISH", text_color=wtDown ? color.red : color.green, text_size=size.small)

        table.cell(dashboard, 0, 13, "TEMA Slope:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 13, isTemaFalling ? "FALLING" : "RISING", text_color=isTemaFalling ? color.red : color.green, text_size=size.small)

        // Cooldown status
        cooldownText = cooldownOK ? "OK" : str.tostring(smartCooldown - barsSinceExit) + " bars"
        cooldownColor = cooldownOK ? color.green : color.orange
        table.cell(dashboard, 0, 14, "Cooldown:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 14, cooldownText, text_color=cooldownColor, text_size=size.small)

        // Red bars count (per BEAR)
        redBarsText = str.tostring(redBarsCount) + "/" + str.tostring(bearMinRedBars)
        redBarsColor = hasEnoughRedBars ? color.green : color.gray
        table.cell(dashboard, 0, 15, "Red Bars:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 15, redBarsText, text_color=redBarsColor, text_size=size.small)

        // Losses consecutive
        table.cell(dashboard, 0, 16, "Cons. Loss:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 16, str.tostring(consecutiveLosses) + "/" + str.tostring(maxConsecutiveLosses), text_color=consecutiveLosses >= maxConsecutiveLosses - 1 ? color.orange : color.white, text_size=size.small)

        // Total DD
        table.cell(dashboard, 0, 17, "Total DD:", text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, 17, str.tostring(totalDrawdown * 100, "#.#") + "%", text_color=totalDrawdown > maxTotalDrawdown * 0.7 ? color.orange : color.white, text_size=size.small)

// ═══════════════════════════════════════════════════════════════════════════════
// ALERTS
// ═══════════════════════════════════════════════════════════════════════════════

alertcondition(shortPanic and not inShort, title="PANIC SHORT Signal", message="PANIC SHORT Signal detected! High fear conditions present.")
alertcondition(shortStandard and not inShort, title="Standard SHORT Signal", message="Standard SHORT signal detected in bear market.")
alertcondition(emergencyExit, title="Emergency Exit", message="EMERGENCY EXIT triggered - Strong bounce detected!")
alertcondition(isPanicMode and not isPanicMode[1], title="Panic Mode Activated", message="Market entering PANIC MODE - High volatility and fear detected!")
alertcondition(not drawdownOK and drawdownOK[1], title="Drawdown Protection Active", message="TRADING PAUSED - Drawdown protection triggered. Review risk.")
